// functions/src/index.ts

import dotenvx from "dotenv";
import * as admin from "firebase-admin";
import * as logger from "firebase-functions/logger";
import { onRequest } from "firebase-functions/v2/https";
import { httpHandler } from "./entry/httpHandler";

// export name wie du willst (api, ingest, http, v1, etc.)
export const anoraChat = onRequest(httpHandler);
export const api = anoraChat;

// ---- Umgebungsvariablen laden (.env im functions-Ordner) ----
dotenvx.config();

// ------------------------------------------------------------
// Globale Limits fÃ¼r StabilitÃ¤t (Antworten, Kontext, Wissen)
// ------------------------------------------------------------
const MAX_REPLY_LENGTH = 2000;         // maximale LÃ¤nge der KI-Antwort Richtung Client
const MAX_FACTS_PER_PROMPT = 50;       // wie viele Facts gehen maximal in den Prompt
const MAX_HISTORY_TURNS = 8;           // wie viele Chat-Nachrichten gehen in den Prompt
const MAX_USER_MESSAGE_LENGTH = 2000;  // wie lang darf eine einzelne User-Nachricht Richtung Modell sein
const MAX_KNOWLEDGE_SUMMARY_LENGTH = 4000; // harte Kappung des Wissen-Blocks im Prompt
const MAX_HISTORY_SUMMARY_LENGTH = 2000;   // harte Kappung des Verlauf-Blocks im Prompt

// ------------------------------------------------------------
// SAFETY GUARD: Niemals versehentlich gegen echte Google APIs schreiben
// Wenn Functions Emulator lÃ¤uft, MUSS Firestore Emulator aktiv sein.
// ------------------------------------------------------------
const isLikelyFunctionsEmulator =
  process.env.FUNCTIONS_EMULATOR === "true" ||
  !!process.env.FIREBASE_EMULATOR_HUB ||
  // firebase-tools setzt das oft in Emulator-Runs:
  !!process.env.FUNCTION_TARGET ||
  // sehr grob, aber in Emulator fast immer vorhanden:
  (process.env.GCLOUD_PROJECT === "anoraapp-ai" &&
    process.env.NODE_ENV !== "production");

if (isLikelyFunctionsEmulator && !process.env.FIRESTORE_EMULATOR_HOST) {
  throw new Error(
    "SAFETY GUARD: FIRESTORE_EMULATOR_HOST ist nicht gesetzt. " +
      "Du wÃ¼rdest gegen echte Google APIs/Firestore schreiben. " +
      "Starte: firebase emulators:start --only functions,firestore"
  );
}

if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

// ------------------------------------------------------------

// ---- MOVED OUT: core/meta/contextHelpers.ts (lines 54..153) ----



// ------------------------------------------------------------

// ---- MOVED OUT: parse/sanitize block (lines 157..2601) ----


    // ------------------------------------------------------------
// PHASE 4.2.3: Guard anwenden â€“ Core-Grenzen erzwingen
// ------------------------------------------------------------
const guard = enforceCoreResponseBoundaries(safeResult.reply);

if (!guard.ok) {
  logger.warn("core_guard_violation", {
    userId: input.userId,
    violations: guard.violations,
  });

  // Harte Grenze: neutrale, sichere Antwort.
  // Keine Actions/Tasks/NewFacts â€“ nichts Autonomes ausfÃ¼hren.
  safeResult.reply =
    "Ich kann dabei nicht helfen, etwas Eskalierendes/Manipulatives zu formulieren. " +
    "Sag mir stattdessen kurz das Ziel (z.B. sachlich klÃ¤ren, rechtlich prÃ¼fen, nÃ¤chsten Schritt planen), " +
    "dann formuliere ich es neutral und sauber.";

  safeResult.actions = [];
  safeResult.tasks = [];
  safeResult.newFacts = [];
} else {
  logger.info("core_guard_ok", { userId: input.userId });
}

    // ðŸ‘‰ WICHTIG:
    // - Nur "actions" werden serverseitig interpretiert (z.B. reset_context / set_context).
    // - "tasks" sind ausschlieÃŸlich Hinweise fÃ¼r die UI / den Nutzer.
    // - Der Server lÃ¶st KEINE Cronjobs, Push-Tasks oder sonstige Aktionen aus Tasks aus.
    //
    // Damit bleibt Anora explizit nicht-autonom: sie schlÃ¤gt nur vor, der Mensch entscheidet und handelt.

    if (safeResult.actions.length > 0) {
  await executeBrainActions(input.userId, safeResult.actions);
}

if (safeResult.newFacts.length > 0) {
  // Legacy-BrainFacts werden NICHT mehr persistiert.
  // newFacts dienen nur noch als transienter Kontext.
  await updatePropertyContextFromNewFacts(input.userId, safeResult.newFacts);
  await updateMietrechtContextFromFacts(input.userId, safeResult.newFacts);
}

try {
  // Minimal: persistiere ALLE Chat-Facts 1:1 als "chat.memory" in facts_v1
  // (spÃ¤ter kÃ¶nnen wir property/tenant sauber mappen)
  const toUpsert = safeResult.newFacts.map((f, idx) => ({
    domain: "chat",
    key: "memory",
    entityId: `user:${input.userId}`, // simpel, stabil
    value: {
      type: f.type,
      tags: Array.isArray(f.tags) ? f.tags : [],
      data: f.data ?? {},
      raw: f.raw ?? "",
      seq: idx,
    },
    meta: {
      source: "chat",
      ts: Date.now(),
    },
  }));

  const r = await upsertManyFacts(input.userId, toUpsert as any);

  logger.info("chat_memory_upserted_v1", {
    userId: input.userId,
    count: toUpsert.length,
    result: r,
  });
} catch (err) {
  logger.error("chat_memory_upsert_failed_v1", {
    userId: input.userId,
    error: String(err),
  });
}

    // Presence-Logik v1: Kandidaten aus Chat + Tasks prÃ¼fen
    // - passiv, keine Autohandlungen
    // - strikt rate-limitiert
    try {
      await generatePresenceFromChatIfAllowed(input.userId, input, safeResult);
    } catch (err) {
      logger.error("presence_generation_failed", {
        userId: input.userId,
        error: String(err),
      });
    }

    const response: BrainOutput = safeResult;

    res.status(200).json(response);

  } catch (err) {
    logger.error("Fehler in anoraChat:", err);
    res.status(500).json({ error: "Internal server error" });
  }
});


// ---- MOVED OUT: legacy/presence_endpoints.ts.txt (lines 163..667) ----

// ------------------------------------------------------------
// HTTPS Endpoint: komplettes Wissen eines Users lÃ¶schen
// (Panic-Reset â€“ NUR aus Einstellungen aufrufen!)
// ------------------------------------------------------------

