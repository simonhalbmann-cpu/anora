// ------------------------------------------------------------
// Presence: letzte sichtbare Presence-Karte laden
// (statt nur status == "pending")
// ------------------------------------------------------------
async function getLatestVisiblePresenceEvent(
  userId: string
): Promise<{ id: string; data: PresenceEventDoc } | null> {
  const col = db
    .collection("brain")
    .doc(userId)
    .collection("presenceEvents");

  const now = Date.now();

  // NEU: Themen-Block-Meta laden
  const topicMeta = await getPresenceTopicMeta(userId);

  // Wir holen die letzten ~50 Events nach Zeit, filtern dann im Code
  const snap = await col
    .orderBy("createdAt", "desc")
    .limit(50)
    .get();

  if (snap.empty) return null;

  for (const doc of snap.docs) {
    const data = doc.data() as PresenceEventDoc;

    // 0) Themen-Block prÃ¼fen (Topic global geblockt?)
    if (data.topic) {
      const t = data.topic as PresenceTopic;
      const state = topicMeta[t];
      if (
        state &&
        typeof state.blockedUntil === "number" &&
        state.blockedUntil > now
      ) {
        // dieses Thema ist gerade global geblockt -> nicht anzeigen
        continue;
      }
    }

    // 1) Themen, die explizit abgeschaltet wurden, NIE mehr anzeigen
    if (data.status === "dismissed") {
      continue;
    }

    // 2) Snoozed-Events nur anzeigen, wenn ihre Snooze-Zeit abgelaufen ist
    if (
      data.status === "snoozed" &&
      typeof data.snoozedUntil === "number" &&
      data.snoozedUntil > now
    ) {
      continue;
    }

    // 3) Alles andere (pending, shown, alte snoozed) ist sichtbar
    return { id: doc.id, data };
  }

  // nichts Sichtbares gefunden
  return null;
}

// ------------------------------------------------------------
// HTTPS Endpoint: Anora Presence â€“ nÃ¤chste Presence-Karte laden
// ------------------------------------------------------------
export const anoraPresence = onRequest(async (req, res) => {
  try {
    if (req.method !== "POST") {
      res.status(405).json({ error: "Only POST allowed" });
      return;
    }

    let body: any = req.body;
    if (typeof body === "string") {
      try {
        body = JSON.parse(body);
      } catch {
        res.status(400).json({ error: "Invalid JSON body" });
        return;
      }
    }

    if (!body) {
      res.status(400).json({ error: "Missing request body" });
      return;
    }

    const { userId } = body;

    // userId validieren â€“ gleiche Logik wie bei anoraChat
    if (typeof userId !== "string") {
      res.status(400).json({ error: "Missing or invalid userId" });
      return;
    }

    const trimmedUserId = userId.trim();
    const userIdPattern = /^[a-zA-Z0-9_-]{1,128}$/;
    if (!userIdPattern.test(trimmedUserId)) {
      logger.warn("anoraPresence_invalid_userId_pattern", {
        rawUserId: userId,
      });
      res.status(400).json({ error: "Invalid userId format" });
      return;
    }

    // Presence-Opt-out respektieren
    const enabled = await isPresenceEnabledForUser(trimmedUserId);
    if (!enabled) {
      logger.info("anoraPresence_opt_out_active", { userId: trimmedUserId });
      res.status(200).json({
        ok: true,
        event: null,
      });
      return;
    }

    // Neu: letzte sichtbare Presence holen
    const next = await getLatestVisiblePresenceEvent(trimmedUserId);
    if (!next) {
      // Kein Event -> einfach ok + null zurÃ¼ckgeben
      res.status(200).json({
        ok: true,
        event: null,
      });
      return;
    }

    logger.info("anoraPresence_next_event", {
      userId: trimmedUserId,
      eventId: next.id,
      type: next.data.type,
      status: next.data.status,
    });

    res.status(200).json({
      id: next.id,
      event: next.data,
    });
  } catch (err) {
    logger.error("anoraPresence_error", { error: String(err) });
    res
      .status(500)
      .json({ error: "Internal server error in anoraPresence" });
  }
});

// ------------------------------------------------------------
// HTTPS Endpoint: Anora Presence Action â€“ Button-Aktion speichern
// ------------------------------------------------------------
export const anoraPresenceAction = onRequest(async (req, res) => {
  try {
    if (req.method !== "POST") {
      res.status(405).json({ error: "Only POST allowed" });
      return;
    }

    let body: any = req.body;
    if (typeof body === "string") {
      try {
        body = JSON.parse(body);
      } catch {
        res.status(400).json({ error: "Invalid JSON body" });
        return;
      }
    }

    if (!body) {
      res.status(400).json({ error: "Missing request body" });
      return;
    }

    const { userId, eventId, action } = body;

    // userId validieren â€“ gleiche Logik wie bei anoraChat
    if (typeof userId !== "string") {
      res.status(400).json({ error: "Missing or invalid userId" });
      return;
    }
    const trimmedUserId = userId.trim();
    const userIdPattern = /^[a-zA-Z0-9_-]{1,128}$/;
    if (!userIdPattern.test(trimmedUserId)) {
      logger.warn("anoraPresenceAction_invalid_userId_pattern", {
        rawUserId: userId,
      });
      res.status(400).json({ error: "Invalid userId format" });
      return;
    }

    // eventId prÃ¼fen
    if (typeof eventId !== "string" || !eventId.trim()) {
      res.status(400).json({ error: "Missing or invalid eventId" });
      return;
    }

    // action prÃ¼fen
    if (
      action !== "view_now" &&
      action !== "snooze" &&
      action !== "disable"
    ) {
      res.status(400).json({ error: "Invalid action" });
      return;
    }

   const now = Date.now();

    // 1) Falls "disable": Event laden und Thema bestimmen
    let topicToBlock: PresenceTopic | null = null;

    if (action === "disable") {
      try {
        const eventSnap = await db
          .collection("brain")
          .doc(trimmedUserId)
          .collection("presenceEvents")
          .doc(eventId.trim())
          .get();

        if (eventSnap.exists) {
          const data = eventSnap.data() as PresenceEventDoc;

          if (data.topic) {
  topicToBlock = data.topic;
}
        }
      } catch (err) {
        logger.error("anoraPresenceAction_load_event_failed", {
          userId: trimmedUserId,
          eventId,
          error: String(err),
        });
      }
    }

    // 2) Status-Update vorbereiten
    let updates: {
      status?: PresenceEventStatus;
      shownAt?: number | null;
      dismissedAt?: number | null;
      snoozedUntil?: number | null;
    } = {};

    if (action === "view_now") {
      updates = {
        status: "shown",
        shownAt: now,
      };
    } else if (action === "snooze") {
      const THREE_HOURS = 3 * 60 * 60 * 1000;
      updates = {
        status: "snoozed",
        snoozedUntil: now + THREE_HOURS,
      };
    } else if (action === "disable") {
      updates = {
        status: "dismissed",
        dismissedAt: now,
      };
    }

    // 2) Event-Status in Firestore schreiben
    await updatePresenceEventStatus(
      trimmedUserId,
      eventId.trim(),
      updates
    );

    // 3) Falls "disable": Themen fÃ¼r 90 Tage muten
    // 3) Falls "disable": Thema fÃ¼r 90 Tage blocken (presenceTopics-Meta)
    if (action === "disable" && topicToBlock) {
      const BLOCK_DURATION_DAYS = 90;
      const BLOCK_DURATION_MS = BLOCK_DURATION_DAYS * 24 * 60 * 60 * 1000;
      const blockedUntil = now + BLOCK_DURATION_MS;

      try {
        await updatePresenceTopicMeta(
          trimmedUserId,
          topicToBlock,
          blockedUntil,
          now
        );

        logger.info("anoraPresenceAction_topic_block_set", {
          userId: trimmedUserId,
          eventId,
          topic: topicToBlock,
          blockedUntil,
        });
      } catch (err) {
        logger.error("anoraPresenceAction_topic_block_failed", {
          userId: trimmedUserId,
          eventId,
          topic: topicToBlock,
          error: String(err),
        });
      }
    }

    logger.info("anoraPresenceAction_ok", {
      userId: trimmedUserId,
      eventId,
      action,
    });

    res.status(200).json({
      ok: true,
    });

  } catch (err) {
    logger.error("anoraPresenceAction_error", { error: String(err) });
    res
      .status(500)
      .json({ error: "Internal server error in anoraPresenceAction" });
  }
});

// ------------------------------------------------------------
// HTTPS Endpoint: Anora Presence Settings â€“ Presence ein/aus
// ------------------------------------------------------------
export const anoraPresenceSettings = onRequest(async (req, res) => {
  try {
    if (req.method !== "POST") {
      res.status(405).json({ error: "Only POST allowed" });
      return;
    }

    let body: any = req.body;
    if (typeof body === "string") {
      try {
        body = JSON.parse(body);
      } catch {
        res.status(400).json({ error: "Invalid JSON body" });
        return;
      }
    }

    if (!body) {
      res.status(400).json({ error: "Missing request body" });
      return;
    }

    const { userId, enabled } = body;

    // userId validieren â€“ gleiche Logik wie bei anoraChat
    if (typeof userId !== "string") {
      res.status(400).json({ error: "Missing or invalid userId" });
      return;
    }

    const trimmedUserId = userId.trim();
    const userIdPattern = /^[a-zA-Z0-9_-]{1,128}$/;
    if (!userIdPattern.test(trimmedUserId)) {
      logger.warn("anoraPresenceSettings_invalid_userId_pattern", {
        rawUserId: userId,
      });
      res.status(400).json({ error: "Invalid userId format" });
      return;
    }

    // enabled prÃ¼fen
    if (typeof enabled !== "boolean") {
      res.status(400).json({ error: "Missing or invalid enabled flag" });
      return;
    }

    // Presence-Flag setzen
    await setPresenceEnabledForUser(trimmedUserId, enabled);

    logger.info("anoraPresenceSettings_ok", {
      userId: trimmedUserId,
      enabled,
    });

    res.status(200).json({
      ok: true,
      enabled, // <- das kommt aus dem Request-Body
    });
  } catch (err) {
    logger.error("anoraPresenceSettings_error", { error: String(err) });
    res
      .status(500)
      .json({ error: "Internal server error in anoraPresenceSettings" });
  }
});

// ------------------------------------------------------------
// HTTPS Endpoint: Presence Topics â€“ Themen muten / anzeigen
// ------------------------------------------------------------
export const anoraPresenceTopics = onRequest(async (req, res) => {
  try {
    if (req.method !== "POST") {
      res.status(405).json({ error: "Only POST allowed" });
      return;
    }

    let body: any = req.body;
    if (typeof body === "string") {
      try {
        body = JSON.parse(body);
      } catch {
        res.status(400).json({ error: "Invalid JSON body" });
        return;
      }
    }

    if (!body) {
      res.status(400).json({ error: "Missing request body" });
      return;
    }

    const { userId, topic, muted } = body;

    // userId validieren â€“ gleiche Logik wie bei anoraChat
    if (typeof userId !== "string") {
      res.status(400).json({ error: "Missing or invalid userId" });
      return;
    }

    const trimmedUserId = userId.trim();
    const userIdPattern = /^[a-zA-Z0-9_-]{1,128}$/;
    if (!userIdPattern.test(trimmedUserId)) {
      logger.warn("anoraPresenceTopics_invalid_userId_pattern", {
        rawUserId: userId,
      });
      res.status(400).json({ error: "Invalid userId format" });
      return;
    }

    // Wenn KEIN topic Ã¼bergeben wird -> nur aktuelle Topic-States zurÃ¼ckgeben
    if (typeof topic !== "string") {
      const topicMeta = await getPresenceTopicMeta(trimmedUserId);

      logger.info("anoraPresenceTopics_read_only", {
        userId: trimmedUserId,
      });

      res.status(200).json({
        ok: true,
        userId: trimmedUserId,
        topics: topicMeta,
      });
      return;
    }

    // Ab hier: konkretes Topic muten / entmuten
    // Wir erlauben nur die Themen, die wir real nutzen
    const allowedTopics: PresenceTopic[] = [
      "stress_cluster",
      "money_decision",
      "project_followup",
      "location_watch",
      "other",
    ];

    if (!allowedTopics.includes(topic as PresenceTopic)) {
      res.status(400).json({ error: "Invalid topic" });
      return;
    }

    if (typeof muted !== "boolean") {
      res.status(400).json({ error: "Missing or invalid muted flag" });
      return;
    }

    const now = Date.now();

    // Wenn muted=true -> 90 Tage blocken
    // Wenn muted=false -> Block aufheben (blockedUntil in die Vergangenheit setzen)
    const BLOCK_DURATION_DAYS = 90;
    const BLOCK_DURATION_MS = BLOCK_DURATION_DAYS * 24 * 60 * 60 * 1000;

    const blockedUntil = muted ? now + BLOCK_DURATION_MS : 0;
    const lastDisabledAt = muted ? now : now; // wir protokollieren einfach jetzt

    await updatePresenceTopicMeta(
      trimmedUserId,
      topic as PresenceTopic,
      blockedUntil,
      lastDisabledAt
    );

    const topicMeta = await getPresenceTopicMeta(trimmedUserId);

    logger.info("anoraPresenceTopics_topic_updated", {
      userId: trimmedUserId,
      topic,
      muted,
      blockedUntil,
    });

    res.status(200).json({
      ok: true,
      userId: trimmedUserId,
      topics: topicMeta,
    });
  } catch (err) {
    logger.error("anoraPresenceTopics_error", { error: String(err) });
    res
      .status(500)
      .json({ error: "Internal server error in anoraPresenceTopics" });
  }
});

